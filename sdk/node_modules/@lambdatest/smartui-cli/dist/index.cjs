#!/usr/bin/env node
'use strict';

var commander = require('commander');
var which = require('which');
var listr2 = require('listr2');
var chalk8 = require('chalk');
var path2 = require('path');
var fastify = require('fastify');
var fs4 = require('fs');
var test = require('@playwright/test');
var Ajv = require('ajv');
var addErrors = require('ajv-errors');
var winston = require('winston');
var FormData = require('form-data');
var axios = require('axios');
var child_process = require('child_process');
var spawn = require('cross-spawn');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var which__default = /*#__PURE__*/_interopDefault(which);
var chalk8__default = /*#__PURE__*/_interopDefault(chalk8);
var path2__default = /*#__PURE__*/_interopDefault(path2);
var fastify__default = /*#__PURE__*/_interopDefault(fastify);
var fs4__default = /*#__PURE__*/_interopDefault(fs4);
var Ajv__default = /*#__PURE__*/_interopDefault(Ajv);
var addErrors__default = /*#__PURE__*/_interopDefault(addErrors);
var FormData__default = /*#__PURE__*/_interopDefault(FormData);
var axios__default = /*#__PURE__*/_interopDefault(axios);
var spawn__default = /*#__PURE__*/_interopDefault(spawn);

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/lib/constants.ts
var constants_default = {
  // default configs
  DEFAULT_CONFIG: {
    web: {
      browsers: [
        "chrome",
        "firefox",
        "safari",
        "edge"
      ],
      viewports: [
        [1920],
        [1366],
        [1028]
      ]
    },
    mobile: {
      devices: [
        "iPhone 14",
        "Galaxy S24"
      ],
      fullPage: true,
      orientation: "portrait"
    },
    waitForTimeout: 1e3,
    enableJavaScript: false,
    allowedHostnames: []
  },
  DEFAULT_WEB_STATIC_CONFIG: [
    {
      "name": "lambdatest-home-page",
      "url": "https://www.lambdatest.com",
      "waitForTimeout": 1e3
    },
    {
      "name": "example-page",
      "url": "https://example.com/"
    }
  ],
  // browsers
  CHROME: "chrome",
  SAFARI: "safari",
  FIREFOX: "firefox",
  EDGE: "edge",
  EDGE_CHANNEL: "msedge",
  WEBKIT: "webkit",
  // user agents
  CHROME_USER_AGENT: "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.6312.107 Safari/537.3",
  FIREFOX_USER_AGENT: "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:112.0) Gecko/20100101 Firefox/112.0",
  SAFARI_USER_AGENT: "Mozilla/5.0 (Macintosh; Intel Mac OS X 13_3) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.4 Safari/605.1.15",
  EDGE_USER_AGENT: "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.0.0 Safari/537.36 Edg/113.0.1774.35",
  // viewports
  MIN_VIEWPORT_HEIGHT: 1080,
  // mobile
  MOBILE_OS_ANDROID: "android",
  MOBILE_OS_IOS: "ios",
  MOBILE_ORIENTATION_PORTRAIT: "portrait",
  MOBILE_ORIENTATION_LANDSCAPE: "landscape",
  // CI
  GITHUB_API_HOST: "https://api.github.com",
  SUPPORTED_MOBILE_DEVICES: {
    "Blackberry KEY2 LE": { os: "android", viewport: { width: 412, height: 618 } },
    "Galaxy A12": { os: "android", viewport: { width: 360, height: 800 } },
    "Galaxy A21s": { os: "android", viewport: { width: 412, height: 915 } },
    "Galaxy A22": { os: "android", viewport: { width: 358, height: 857 } },
    "Galaxy A31": { os: "android", viewport: { width: 412, height: 915 } },
    "Galaxy A32": { os: "android", viewport: { width: 412, height: 915 } },
    "Galaxy A51": { os: "android", viewport: { width: 412, height: 915 } },
    "Galaxy A7": { os: "android", viewport: { width: 412, height: 846 } },
    "Galaxy A70": { os: "android", viewport: { width: 412, height: 915 } },
    "Galaxy A8": { os: "android", viewport: { width: 360, height: 740 } },
    "Galaxy A8 Plus": { os: "android", viewport: { width: 412, height: 846 } },
    "Galaxy J7 Prime": { os: "android", viewport: { width: 360, height: 640 } },
    "Galaxy M12": { os: "android", viewport: { width: 412, height: 915 } },
    "Galaxy M31": { os: "android", viewport: { width: 412, height: 892 } },
    "Galaxy Note10": { os: "android", viewport: { width: 412, height: 869 } },
    "Galaxy Note10 Plus": { os: "android", viewport: { width: 412, height: 869 } },
    "Galaxy Note20": { os: "android", viewport: { width: 412, height: 915 } },
    "Galaxy Note20 Ultra": { os: "android", viewport: { width: 412, height: 869 } },
    "Galaxy S10": { os: "android", viewport: { width: 360, height: 760 } },
    "Galaxy S10 Plus": { os: "android", viewport: { width: 412, height: 869 } },
    "Galaxy S10e": { os: "android", viewport: { width: 412, height: 740 } },
    "Galaxy S20": { os: "android", viewport: { width: 360, height: 800 } },
    "Galaxy S20 FE": { os: "android", viewport: { width: 412, height: 914 } },
    "Galaxy S20 Ultra": { os: "android", viewport: { width: 412, height: 915 } },
    "Galaxy S20 Plus": { os: "android", viewport: { width: 384, height: 854 } },
    "Galaxy S21": { os: "android", viewport: { width: 360, height: 800 } },
    "Galaxy S21 FE": { os: "android", viewport: { width: 360, height: 780 } },
    "Galaxy S21 Ultra": { os: "android", viewport: { width: 384, height: 854 } },
    "Galaxy S21 Plus": { os: "android", viewport: { width: 360, height: 800 } },
    "Galaxy S22": { os: "android", viewport: { width: 360, height: 780 } },
    "Galaxy S22 Ultra": { os: "android", viewport: { width: 384, height: 854 } },
    "Galaxy S23": { os: "android", viewport: { width: 360, height: 645 } },
    "Galaxy S23 Plus": { os: "android", viewport: { width: 360, height: 648 } },
    "Galaxy S23 Ultra": { os: "android", viewport: { width: 384, height: 689 } },
    "Galaxy S24": { os: "android", viewport: { width: 360, height: 780 } },
    "Galaxy S24 Plus": { os: "android", viewport: { width: 384, height: 832 } },
    "Galaxy S24 Ultra": { os: "android", viewport: { width: 384, height: 832 } },
    "Galaxy S7": { os: "android", viewport: { width: 360, height: 640 } },
    "Galaxy S7 Edge": { os: "android", viewport: { width: 360, height: 640 } },
    "Galaxy S8": { os: "android", viewport: { width: 360, height: 740 } },
    "Galaxy S8 Plus": { os: "android", viewport: { width: 360, height: 740 } },
    "Galaxy S9": { os: "android", viewport: { width: 360, height: 740 } },
    "Galaxy S9 Plus": { os: "android", viewport: { width: 360, height: 740 } },
    "Galaxy Tab A7 Lite": { os: "android", viewport: { width: 534, height: 894 } },
    "Galaxy Tab A8": { os: "android", viewport: { width: 800, height: 1280 } },
    "Galaxy Tab S3": { os: "android", viewport: { width: 1024, height: 768 } },
    "Galaxy Tab S4": { os: "android", viewport: { width: 712, height: 1138 } },
    "Galaxy Tab S7": { os: "android", viewport: { width: 800, height: 1192 } },
    "Galaxy Tab S8": { os: "android", viewport: { width: 753, height: 1205 } },
    "Galaxy Tab S8 Plus": { os: "android", viewport: { width: 825, height: 1318 } },
    "Huawei Mate 20 Pro": { os: "android", viewport: { width: 360, height: 780 } },
    "Huawei P20 Pro": { os: "android", viewport: { width: 360, height: 747 } },
    "Huawei P30": { os: "android", viewport: { width: 360, height: 780 } },
    "Huawei P30 Pro": { os: "android", viewport: { width: 360, height: 780 } },
    "Microsoft Surface Duo": { os: "android", viewport: { width: 1114, height: 705 } },
    "Moto G7 Play": { os: "android", viewport: { width: 360, height: 760 } },
    "Moto G9 Play": { os: "android", viewport: { width: 393, height: 786 } },
    "Moto G Stylus (2022)": { os: "android", viewport: { width: 432, height: 984 } },
    "Nexus 5": { os: "android", viewport: { width: 360, height: 640 } },
    "Nexus 5X": { os: "android", viewport: { width: 412, height: 732 } },
    "Nokia 5": { os: "android", viewport: { width: 360, height: 640 } },
    "Nothing Phone (1)": { os: "android", viewport: { width: 412, height: 915 } },
    "OnePlus 10 Pro": { os: "android", viewport: { width: 412, height: 919 } },
    "OnePlus 11": { os: "android", viewport: { width: 360, height: 804 } },
    "OnePlus 6": { os: "android", viewport: { width: 412, height: 869 } },
    "OnePlus 6T": { os: "android", viewport: { width: 412, height: 892 } },
    "OnePlus 7": { os: "android", viewport: { width: 412, height: 892 } },
    "OnePlus 7T": { os: "android", viewport: { width: 412, height: 914 } },
    "OnePlus 8": { os: "android", viewport: { width: 412, height: 915 } },
    "OnePlus 9": { os: "android", viewport: { width: 411, height: 915 } },
    "OnePlus 9 Pro": { os: "android", viewport: { width: 412, height: 919 } },
    "OnePlus Nord": { os: "android", viewport: { width: 412, height: 914 } },
    "OnePlus Nord 2": { os: "android", viewport: { width: 412, height: 915 } },
    "OnePlus Nord CE": { os: "android", viewport: { width: 412, height: 915 } },
    "Oppo A12": { os: "android", viewport: { width: 360, height: 760 } },
    "Oppo A15": { os: "android", viewport: { width: 360, height: 800 } },
    "Oppo A54": { os: "android", viewport: { width: 360, height: 800 } },
    "Oppo A5s": { os: "android", viewport: { width: 360, height: 760 } },
    "Oppo F17": { os: "android", viewport: { width: 360, height: 800 } },
    "Oppo K10": { os: "android", viewport: { width: 360, height: 804 } },
    "Pixel 3": { os: "android", viewport: { width: 412, height: 823 } },
    "Pixel 3 XL": { os: "android", viewport: { width: 412, height: 846 } },
    "Pixel 3a": { os: "android", viewport: { width: 412, height: 823 } },
    "Pixel 4": { os: "android", viewport: { width: 392, height: 830 } },
    "Pixel 4 XL": { os: "android", viewport: { width: 412, height: 823 } },
    "Pixel 4a": { os: "android", viewport: { width: 393, height: 851 } },
    "Pixel 5": { os: "android", viewport: { width: 393, height: 851 } },
    "Pixel 6": { os: "android", viewport: { width: 393, height: 786 } },
    "Pixel 6 Pro": { os: "android", viewport: { width: 412, height: 892 } },
    "Pixel 7": { os: "android", viewport: { width: 412, height: 915 } },
    "Pixel 7 Pro": { os: "android", viewport: { width: 412, height: 892 } },
    "Pixel 8": { os: "android", viewport: { width: 412, height: 915 } },
    "Pixel 8 Pro": { os: "android", viewport: { width: 448, height: 998 } },
    "Poco M2 Pro": { os: "android", viewport: { width: 393, height: 873 } },
    "POCO X3 Pro": { os: "android", viewport: { width: 393, height: 873 } },
    "Realme 5i": { os: "android", viewport: { width: 360, height: 800 } },
    "Realme 7i": { os: "android", viewport: { width: 360, height: 800 } },
    "Realme 8i": { os: "android", viewport: { width: 360, height: 804 } },
    "Realme C21Y": { os: "android", viewport: { width: 360, height: 800 } },
    "Realme C21": { os: "android", viewport: { width: 360, height: 800 } },
    "Realme GT2 Pro": { os: "android", viewport: { width: 360, height: 804 } },
    "Redmi 8": { os: "android", viewport: { width: 360, height: 760 } },
    "Redmi 9": { os: "android", viewport: { width: 360, height: 800 } },
    "Redmi 9C": { os: "android", viewport: { width: 360, height: 800 } },
    "Redmi Note 10 Pro": { os: "android", viewport: { width: 393, height: 873 } },
    "Redmi Note 8": { os: "android", viewport: { width: 393, height: 851 } },
    "Redmi Note 8 Pro": { os: "android", viewport: { width: 393, height: 851 } },
    "Redmi Note 9": { os: "android", viewport: { width: 393, height: 851 } },
    "Redmi Note 9 Pro Max": { os: "android", viewport: { width: 393, height: 873 } },
    "Redmi Y2": { os: "android", viewport: { width: 360, height: 720 } },
    "Tecno Spark 7": { os: "android", viewport: { width: 360, height: 800 } },
    "Vivo Y22": { os: "android", viewport: { width: 385, height: 860 } },
    "Vivo T1": { os: "android", viewport: { width: 393, height: 873 } },
    "Vivo V7": { os: "android", viewport: { width: 360, height: 720 } },
    "Vivo Y11": { os: "android", viewport: { width: 360, height: 722 } },
    "Vivo Y12": { os: "android", viewport: { width: 360, height: 722 } },
    "Vivo Y20g": { os: "android", viewport: { width: 385, height: 854 } },
    "Vivo Y50": { os: "android", viewport: { width: 393, height: 786 } },
    "Xiaomi 12 Pro": { os: "android", viewport: { width: 412, height: 915 } },
    "Xperia Z5": { os: "android", viewport: { width: 360, height: 640 } },
    "Xperia Z5 Dual": { os: "android", viewport: { width: 360, height: 640 } },
    "Zenfone 6": { os: "android", viewport: { width: 412, height: 892 } },
    "iPad 10.2 (2019)": { os: "ios", viewport: { width: 810, height: 1080 } },
    "iPad 10.2 (2020)": { os: "ios", viewport: { width: 834, height: 1194 } },
    "iPad 10.2 (2021)": { os: "ios", viewport: { width: 810, height: 1080 } },
    "iPad 9.7 (2017)": { os: "ios", viewport: { width: 768, height: 1024 } },
    "iPad Air (2019)": { os: "ios", viewport: { width: 834, height: 1112 } },
    "iPad Air (2020)": { os: "ios", viewport: { width: 820, height: 1180 } },
    "iPad Air (2022)": { os: "ios", viewport: { width: 820, height: 1180 } },
    "iPad mini (2019)": { os: "ios", viewport: { width: 768, height: 1024 } },
    "iPad mini (2021)": { os: "ios", viewport: { width: 744, height: 1133 } },
    "iPad Pro 11 (2021)": { os: "ios", viewport: { width: 834, height: 1194 } },
    "iPad Pro 11 (2022)": { os: "ios", viewport: { width: 834, height: 1194 } },
    "iPad Pro 12.9 (2018)": { os: "ios", viewport: { width: 1024, height: 1366 } },
    "iPad Pro 12.9 (2020)": { os: "ios", viewport: { width: 1024, height: 1366 } },
    "iPad Pro 12.9 (2021)": { os: "ios", viewport: { width: 1024, height: 1366 } },
    "iPad Pro 12.9 (2022)": { os: "ios", viewport: { width: 1024, height: 1366 } },
    "iPhone 11": { os: "ios", viewport: { width: 375, height: 812 } },
    "iPhone 11 Pro": { os: "ios", viewport: { width: 375, height: 812 } },
    "iPhone 11 Pro Max": { os: "ios", viewport: { width: 414, height: 896 } },
    "iPhone 12": { os: "ios", viewport: { width: 390, height: 844 } },
    "iPhone 12 Mini": { os: "ios", viewport: { width: 375, height: 812 } },
    "iPhone 12 Pro": { os: "ios", viewport: { width: 390, height: 844 } },
    "iPhone 12 Pro Max": { os: "ios", viewport: { width: 428, height: 926 } },
    "iPhone 13": { os: "ios", viewport: { width: 390, height: 844 } },
    "iPhone 13 Mini": { os: "ios", viewport: { width: 390, height: 844 } },
    "iPhone 13 Pro": { os: "ios", viewport: { width: 390, height: 844 } },
    "iPhone 13 Pro Max": { os: "ios", viewport: { width: 428, height: 926 } },
    "iPhone 14": { os: "ios", viewport: { width: 390, height: 844 } },
    "iPhone 14 Plus": { os: "ios", viewport: { width: 428, height: 926 } },
    "iPhone 14 Pro": { os: "ios", viewport: { width: 390, height: 844 } },
    "iPhone 14 Pro Max": { os: "ios", viewport: { width: 428, height: 928 } },
    "iPhone 15": { os: "ios", viewport: { width: 393, height: 852 } },
    "iPhone 15 Plus": { os: "ios", viewport: { width: 430, height: 932 } },
    "iPhone 15 Pro": { os: "ios", viewport: { width: 393, height: 852 } },
    "iPhone 15 Pro Max": { os: "ios", viewport: { width: 430, height: 932 } },
    "iPhone 6": { os: "ios", viewport: { width: 375, height: 667 } },
    "iPhone 6s": { os: "ios", viewport: { width: 375, height: 667 } },
    "iPhone 6s Plus": { os: "ios", viewport: { width: 414, height: 736 } },
    "iPhone 7": { os: "ios", viewport: { width: 375, height: 667 } },
    "iPhone 7 Plus": { os: "ios", viewport: { width: 414, height: 736 } },
    "iPhone 8": { os: "ios", viewport: { width: 375, height: 667 } },
    "iPhone 8 Plus": { os: "ios", viewport: { width: 414, height: 736 } },
    "iPhone SE (2016)": { os: "ios", viewport: { width: 320, height: 568 } },
    "iPhone SE (2020)": { os: "ios", viewport: { width: 375, height: 667 } },
    "iPhone SE (2022)": { os: "ios", viewport: { width: 375, height: 667 } },
    "iPhone X": { os: "ios", viewport: { width: 375, height: 812 } },
    "iPhone XR": { os: "ios", viewport: { width: 414, height: 896 } },
    "iPhone XS": { os: "ios", viewport: { width: 375, height: 812 } },
    "iPhone XS Max": { os: "ios", viewport: { width: 414, height: 896 } }
  }
};

// src/lib/utils.ts
function delDir(dir) {
  if (fs4__default.default.existsSync(dir)) {
    fs4__default.default.rmSync(dir, { recursive: true });
  }
}
function scrollToBottomAndBackToTop({
  frequency = 100,
  timing = 8,
  remoteWindow = window
} = {}) {
  return new Promise((resolve) => {
    let scrolls = 1;
    let scrollLength = remoteWindow.document.body.scrollHeight / frequency;
    (function scroll() {
      let scrollBy = scrollLength * scrolls;
      remoteWindow.setTimeout(() => {
        remoteWindow.scrollTo(0, scrollBy);
        if (scrolls < frequency) {
          scrolls += 1;
          scroll();
        }
        if (scrolls === frequency) {
          remoteWindow.setTimeout(() => {
            remoteWindow.scrollTo(0, 0);
            resolve();
          }, timing);
        }
      }, timing);
    })();
  });
}
function launchBrowsers(ctx) {
  return __async(this, null, function* () {
    let browsers = {};
    let launchOptions = { headless: true };
    if (ctx.config.web) {
      for (const browser of ctx.config.web.browsers) {
        switch (browser) {
          case constants_default.CHROME:
            browsers[constants_default.CHROME] = yield test.chromium.launch(launchOptions);
            break;
          case constants_default.SAFARI:
            browsers[constants_default.SAFARI] = yield test.webkit.launch(launchOptions);
            break;
          case constants_default.FIREFOX:
            browsers[constants_default.FIREFOX] = yield test.firefox.launch(launchOptions);
            break;
          case constants_default.EDGE:
            browsers[constants_default.EDGE] = yield test.chromium.launch(__spreadValues({ channel: constants_default.EDGE_CHANNEL }, launchOptions));
            break;
        }
      }
    }
    if (ctx.config.mobile) {
      for (const device of ctx.config.mobile.devices) {
        if (constants_default.SUPPORTED_MOBILE_DEVICES[device].os === "android" && !browsers[constants_default.CHROME])
          browsers[constants_default.CHROME] = yield test.chromium.launch(launchOptions);
        else if (constants_default.SUPPORTED_MOBILE_DEVICES[device].os === "ios" && !browsers[constants_default.SAFARI])
          browsers[constants_default.SAFARI] = yield test.webkit.launch(launchOptions);
      }
    }
    return browsers;
  });
}
function closeBrowsers(browsers) {
  return __async(this, null, function* () {
    var _a;
    for (const browserName of Object.keys(browsers))
      yield (_a = browsers[browserName]) == null ? void 0 : _a.close();
  });
}
function getWebRenderViewports(ctx) {
  let webRenderViewports = [];
  if (ctx.config.web) {
    for (const viewport of ctx.config.web.viewports) {
      webRenderViewports.push({
        viewport,
        viewportString: `${viewport.width}${viewport.height ? "x" + viewport.height : ""}`,
        fullPage: viewport.height ? false : true,
        device: false
      });
    }
  }
  return webRenderViewports;
}
function getMobileRenderViewports(ctx) {
  var _a;
  let mobileRenderViewports = {};
  mobileRenderViewports[constants_default.MOBILE_OS_IOS] = [];
  mobileRenderViewports[constants_default.MOBILE_OS_ANDROID] = [];
  if (ctx.config.mobile) {
    for (const device of ctx.config.mobile.devices) {
      let os = constants_default.SUPPORTED_MOBILE_DEVICES[device].os;
      let { width, height } = constants_default.SUPPORTED_MOBILE_DEVICES[device].viewport;
      let portrait = ctx.config.mobile.orientation === constants_default.MOBILE_ORIENTATION_PORTRAIT ? true : false;
      (_a = mobileRenderViewports[os]) == null ? void 0 : _a.push({
        viewport: { width: portrait ? width : height, height: portrait ? height : width },
        viewportString: `${device} (${ctx.config.mobile.orientation})`,
        fullPage: ctx.config.mobile.fullPage,
        device: true,
        os
      });
    }
  }
  return mobileRenderViewports;
}
function getRenderViewports(ctx) {
  let mobileRenderViewports = getMobileRenderViewports(ctx);
  return [
    ...getWebRenderViewports(ctx),
    ...mobileRenderViewports[constants_default.MOBILE_OS_IOS],
    ...mobileRenderViewports[constants_default.MOBILE_OS_ANDROID]
  ];
}
var MAX_RESOURCE_SIZE = 5 * 1024 ** 2;
var ALLOWED_RESOURCES = ["document", "stylesheet", "image", "media", "font", "other"];
var ALLOWED_STATUSES = [200, 201];
var REQUEST_TIMEOUT = 1e4;
var MIN_VIEWPORT_HEIGHT = 1080;
var processSnapshot_default = (snapshot, ctx) => __async(void 0, null, function* () {
  ctx.log.debug(`Processing snapshot ${snapshot.name}`);
  if (!ctx.browser)
    ctx.browser = yield test.chromium.launch({ headless: true });
  const context = yield ctx.browser.newContext({ userAgent: constants_default.CHROME_USER_AGENT });
  const page = yield context.newPage();
  let cache = {};
  yield page.route("**/*", (route, request) => __async(void 0, null, function* () {
    const requestUrl = request.url();
    const requestHostname = new URL(requestUrl).hostname;
    try {
      ctx.config.allowedHostnames.push(new URL(snapshot.url).hostname);
      if (ctx.config.enableJavaScript)
        ALLOWED_RESOURCES.push("script");
      const response = yield page.request.fetch(request, { timeout: REQUEST_TIMEOUT });
      const body = yield response.body();
      if (!body) {
        ctx.log.debug(`Handling request ${requestUrl}
 - skipping no response`);
      } else if (!body.length) {
        ctx.log.debug(`Handling request ${requestUrl}
 - skipping empty response`);
      } else if (requestUrl === snapshot.url) {
        ctx.log.debug(`Handling request ${requestUrl}
 - skipping root resource`);
      } else if (!ctx.config.allowedHostnames.includes(requestHostname)) {
        ctx.log.debug(`Handling request ${requestUrl}
 - skipping remote resource`);
      } else if (cache[requestUrl]) {
        ctx.log.debug(`Handling request ${requestUrl}
 - skipping already cached resource`);
      } else if (body.length > MAX_RESOURCE_SIZE) {
        ctx.log.debug(`Handling request ${requestUrl}
 - skipping resource larger than 5MB`);
      } else if (!ALLOWED_STATUSES.includes(response.status())) {
        ctx.log.debug(`Handling request ${requestUrl}
 - skipping disallowed status [${response.status()}]`);
      } else if (!ALLOWED_RESOURCES.includes(request.resourceType())) {
        ctx.log.debug(`Handling request ${requestUrl}
 - skipping disallowed resource type [${request.resourceType()}]`);
      } else {
        ctx.log.debug(`Handling request ${requestUrl}
 - content-type ${response.headers()["content-type"]}`);
        cache[requestUrl] = {
          body: body.toString("base64"),
          type: response.headers()["content-type"]
        };
      }
      route.fulfill({
        status: response.status(),
        headers: response.headers(),
        body
      });
    } catch (error) {
      ctx.log.debug(`Handling request ${requestUrl}
 - aborted due to ${error.message}`);
      route.abort();
    }
  }));
  let options = snapshot.options;
  let optionWarnings = /* @__PURE__ */ new Set();
  let processedOptions = {};
  let selectors = [];
  let ignoreOrSelectDOM;
  let ignoreOrSelectBoxes;
  if (options && Object.keys(options).length) {
    ctx.log.debug(`Snapshot options: ${JSON.stringify(options)}`);
    const isNotAllEmpty = (obj) => {
      var _a;
      for (let key in obj)
        if ((_a = obj[key]) == null ? void 0 : _a.length)
          return true;
      return false;
    };
    if (options.element && Object.keys(options.element).length) {
      if (options.element.id)
        processedOptions.element = "#" + options.element.id;
      else if (options.element.class)
        processedOptions.element = "." + options.element.class;
      else if (options.element.cssSelector)
        processedOptions.element = options.element.cssSelector;
      else if (options.element.xpath)
        processedOptions.element = "xpath=" + options.element.xpath;
    } else if (options.ignoreDOM && Object.keys(options.ignoreDOM).length && isNotAllEmpty(options.ignoreDOM)) {
      processedOptions.ignoreBoxes = {};
      ignoreOrSelectDOM = "ignoreDOM";
      ignoreOrSelectBoxes = "ignoreBoxes";
    } else if (options.selectDOM && Object.keys(options.selectDOM).length && isNotAllEmpty(options.selectDOM)) {
      processedOptions.selectBoxes = {};
      ignoreOrSelectDOM = "selectDOM";
      ignoreOrSelectBoxes = "selectBoxes";
    }
    if (ignoreOrSelectDOM) {
      for (const [key, value] of Object.entries(options[ignoreOrSelectDOM])) {
        switch (key) {
          case "id":
            selectors.push(...value.map((e) => "#" + e));
            break;
          case "class":
            selectors.push(...value.map((e) => "." + e));
            break;
          case "xpath":
            selectors.push(...value.map((e) => "xpath=" + e));
            break;
          case "cssSelector":
            selectors.push(...value);
            break;
        }
      }
    }
  }
  let navigated = false;
  let renderViewports = getRenderViewports(ctx);
  for (const { viewport, viewportString, fullPage } of renderViewports) {
    yield page.setViewportSize({ width: viewport.width, height: viewport.height || MIN_VIEWPORT_HEIGHT });
    ctx.log.debug(`Page resized to ${viewport.width}x${viewport.height || MIN_VIEWPORT_HEIGHT}`);
    if (!navigated) {
      yield page.goto(snapshot.url);
      navigated = true;
      ctx.log.debug(`Navigated to ${snapshot.url}`);
    }
    if (fullPage)
      yield page.evaluate(scrollToBottomAndBackToTop);
    yield page.waitForLoadState("networkidle");
    ctx.log.debug("Network idle 500ms");
    if (processedOptions.element) {
      let l = yield page.locator(processedOptions.element).all();
      if (l.length === 0) {
        throw new Error(`for snapshot ${snapshot.name} viewport ${viewportString}, no element found for selector ${processedOptions.element}`);
      } else if (l.length > 1) {
        throw new Error(`for snapshot ${snapshot.name} viewport ${viewportString}, multiple elements found for selector ${processedOptions.element}`);
      }
    } else if (selectors.length) {
      let locators = [];
      if (!Array.isArray(processedOptions[ignoreOrSelectBoxes][viewportString]))
        processedOptions[ignoreOrSelectBoxes][viewportString] = [];
      for (const selector of selectors) {
        let l = yield page.locator(selector).all();
        if (l.length === 0) {
          optionWarnings.add(`for snapshot ${snapshot.name} viewport ${viewportString}, no element found for selector ${selector}`);
          continue;
        }
        locators.push(...l);
      }
      for (const locator of locators) {
        let bb = yield locator.boundingBox();
        if (bb)
          processedOptions[ignoreOrSelectBoxes][viewportString].push({
            left: bb.x,
            top: bb.y,
            right: bb.x + bb.width,
            bottom: bb.y + bb.height
          });
      }
    }
  }
  yield page.close();
  yield context.close();
  return {
    processedSnapshot: {
      name: snapshot.name,
      url: snapshot.url,
      dom: Buffer.from(snapshot.dom.html).toString("base64"),
      resources: cache,
      options: processedOptions
    },
    warnings: [...optionWarnings, ...snapshot.dom.warnings]
  };
});
var ajv = new Ajv__default.default({ allErrors: true });
ajv.addFormat("web-url", {
  type: "string",
  validate: (url) => {
    try {
      new URL(url.trim());
      return true;
    } catch (error) {
      return false;
    }
  }
});
addErrors__default.default(ajv);
var ConfigSchema = {
  type: "object",
  properties: {
    web: {
      type: "object",
      properties: {
        browsers: {
          type: "array",
          items: { type: "string", enum: [constants_default.CHROME, constants_default.FIREFOX, constants_default.SAFARI, constants_default.EDGE] },
          uniqueItems: true,
          maxItems: 4,
          errorMessage: `Invalid config; allowed browsers - ${constants_default.CHROME}, ${constants_default.FIREFOX}, ${constants_default.SAFARI}, ${constants_default.EDGE}`
        },
        viewports: {
          type: "array",
          items: {
            type: "array",
            oneOf: [
              {
                items: [{ type: "number", minimum: 320, maximum: 7680 }],
                minItems: 1,
                maxItems: 1
              },
              {
                items: [
                  { type: "number", minimum: 320, maximum: 7680 },
                  { type: "number", minimum: 320, maximum: 7680 }
                ],
                minItems: 2,
                maxItems: 2
              }
            ],
            errorMessage: "Invalid config; width/height must be >= 320 and <= 7680"
          },
          uniqueItems: true,
          maxItems: 5,
          errorMessage: "Invalid config; max unique viewports allowed - 5"
        }
      },
      required: ["browsers", "viewports"],
      additionalProperties: false
    },
    mobile: {
      type: "object",
      properties: {
        devices: {
          type: "array",
          items: {
            type: "string",
            enum: Object.keys(constants_default.SUPPORTED_MOBILE_DEVICES),
            minLength: 1,
            errorMessage: {
              enum: "Invalid config; unsupported mobile devices",
              minLength: "Invalid config; mobile device cannot be empty"
            }
          },
          uniqueItems: true,
          maxItems: 20,
          errorMessage: {
            uniqueItems: "Invalid config; duplicate mobile devices",
            maxItems: "Invalid config; max mobile devices allowed - 20"
          }
        },
        fullPage: {
          type: "boolean",
          errorMessage: "Invalid config; fullPage must be true/false"
        },
        orientation: {
          type: "string",
          enum: [constants_default.MOBILE_ORIENTATION_PORTRAIT, constants_default.MOBILE_ORIENTATION_LANDSCAPE],
          errorMessage: `Invalid config; orientation must be ${constants_default.MOBILE_ORIENTATION_PORTRAIT}/${constants_default.MOBILE_ORIENTATION_LANDSCAPE}`
        }
      },
      required: ["devices"],
      additionalProperties: false
    },
    waitForPageRender: {
      type: "number",
      minimum: 0,
      maximum: 3e5,
      errorMessage: "Invalid config; waitForPageRender must be > 0 and <= 300000"
    },
    waitForTimeout: {
      type: "number",
      minimum: 0,
      maximum: 3e4,
      errorMessage: "Invalid config; waitForTimeout must be > 0 and <= 30000"
    },
    enableJavaScript: {
      type: "boolean",
      errorMessage: "Invalid config; enableJavaScript must be true/false"
    },
    allowedHostnames: {
      type: "array",
      items: {
        type: "string",
        minLength: 1,
        errorMessage: {
          minLength: "Invalid config; allowed hostname cannot be empty"
        }
      },
      uniqueItems: true,
      errorMessage: {
        uniqueItems: "Invalid config; duplicates in allowedHostnames"
      }
    }
  },
  anyOf: [
    { required: ["web"] },
    { required: ["mobile"] }
  ],
  additionalProperties: false
};
var WebStaticConfigSchema = {
  type: "array",
  items: {
    type: "object",
    properties: {
      name: {
        type: "string",
        minLength: 1,
        errorMessage: "name is mandatory and cannot be empty"
      },
      url: {
        type: "string",
        format: "web-url",
        errorMessage: "url is mandatory and must be a valid web URL"
      },
      waitForTimeout: {
        type: "number",
        nullable: true,
        minimum: 0,
        maximum: 3e4,
        errorMessage: "waitForTimeout must be > 0 and <= 30000"
      }
    },
    required: ["name", "url"],
    additionalProperties: false
  },
  uniqueItems: true
};
var SnapshotSchema = {
  type: "object",
  properties: {
    name: {
      type: "string",
      minLength: 1,
      errorMessage: "Invalid snapshot; name is mandatory and cannot be empty"
    },
    url: {
      type: "string",
      format: "web-url",
      errorMessage: "Invalid snapshot; url is mandatory and must be a valid web URL"
    },
    dom: {
      type: "object"
    },
    options: {
      type: "object",
      properties: {
        element: {
          type: "object",
          properties: {
            id: {
              type: "string",
              pattern: "^[^;]*$",
              errorMessage: "Invalid snapshot options; element id cannot be empty or have semicolon"
            },
            class: {
              type: "string",
              pattern: "^[^;]*$",
              errorMessage: "Invalid snapshot options; element class cannot be empty or have semicolon"
            },
            cssSelector: {
              type: "string",
              pattern: "^[^;]*$",
              errorMessage: "Invalid snapshot options; element cssSelector cannot be empty or have semicolon"
            },
            xpath: {
              type: "string",
              errorMessage: "Invalid snapshot options; element xpath cannot be empty"
            }
          }
        },
        ignoreDOM: {
          type: "object",
          properties: {
            id: {
              type: "array",
              items: { type: "string", minLength: 1, pattern: "^[^;]*$", errorMessage: "Invalid snapshot options; ignoreDOM id cannot be empty or have semicolon" },
              uniqueItems: true,
              errorMessage: "Invalid snapshot options; ignoreDOM id array must have unique items"
            },
            class: {
              type: "array",
              items: { type: "string", minLength: 1, pattern: "^[^;]*$", errorMessage: "Invalid snapshot options; ignoreDOM class cannot be empty or have semicolon" },
              uniqueItems: true,
              errorMessage: "Invalid snapshot options; ignoreDOM class array must have unique items"
            },
            cssSelector: {
              type: "array",
              items: { type: "string", minLength: 1, pattern: "^[^;]*$", errorMessage: "Invalid snapshot options; ignoreDOM cssSelector cannot be empty or have semicolon" },
              uniqueItems: true,
              errorMessage: "Invalid snapshot options; ignoreDOM cssSelector array must have unique items"
            },
            xpath: {
              type: "array",
              items: { type: "string", minLength: 1 },
              uniqueItems: true,
              errorMessage: "Invalid snapshot options; ignoreDOM xpath array must have unique and non-empty items"
            }
          }
        },
        selectDOM: {
          type: "object",
          properties: {
            id: {
              type: "array",
              items: { type: "string", minLength: 1, pattern: "^[^;]*$", errorMessage: "Invalid snapshot options; selectDOM id cannot be empty or have semicolon" },
              uniqueItems: true,
              errorMessage: "Invalid snapshot options; selectDOM id array must have unique items"
            },
            class: {
              type: "array",
              items: { type: "string", minLength: 1, pattern: "^[^;]*$", errorMessage: "Invalid snapshot options; selectDOM class cannot be empty or have semicolon" },
              uniqueItems: true,
              errorMessage: "Invalid snapshot options; selectDOM class array must have unique items"
            },
            cssSelector: {
              type: "array",
              items: { type: "string", minLength: 1, pattern: "^[^;]*$", errorMessage: "Invalid snapshot options; selectDOM cssSelector cannot be empty or have semicolon" },
              uniqueItems: true,
              errorMessage: "Invalid snapshot options; selectDOM cssSelector array must have unique items"
            },
            xpath: {
              type: "array",
              items: { type: "string", minLength: 1 },
              uniqueItems: true,
              errorMessage: "Invalid snapshot options; selectDOM xpath array must have unique and non-empty items"
            }
          }
        }
      },
      additionalProperties: false
    }
  },
  required: ["name", "url", "dom"],
  additionalProperties: false,
  errorMessage: "Invalid snapshot"
};
var validateConfig = ajv.compile(ConfigSchema);
var validateWebStaticConfig = ajv.compile(WebStaticConfigSchema);
var validateSnapshot = ajv.compile(SnapshotSchema);

// src/lib/server.ts
var server_default = (ctx) => __async(void 0, null, function* () {
  const server = fastify__default.default({ logger: false, bodyLimit: 1e7 });
  const opts = {};
  const SMARTUI_DOM = fs4.readFileSync(path2__default.default.resolve(__dirname, "dom-serializer.js"), "utf-8");
  server.get("/healthcheck", opts, (_, reply) => {
    reply.code(200).send({ cliVersion: ctx.cliVersion });
  });
  server.get("/domserializer", opts, (request, reply) => {
    reply.code(200).send({ data: { dom: SMARTUI_DOM } });
  });
  server.post("/snapshot", opts, (request, reply) => __async(void 0, null, function* () {
    try {
      let { snapshot, testType } = request.body;
      if (!validateSnapshot(snapshot))
        throw new Error(validateSnapshot.errors[0].message);
      let { processedSnapshot, warnings } = yield processSnapshot_default(snapshot, ctx);
      yield ctx.client.uploadSnapshot(ctx.build.id, processedSnapshot, testType, ctx.log);
      ctx.totalSnapshots++;
      reply.code(200).send({ data: { message: "success", warnings } });
    } catch (error) {
      return reply.code(500).send({ error: { message: error.message } });
    }
  }));
  yield server.listen();
  let { port } = server.addresses()[0];
  process.env.SMARTUI_SERVER_ADDRESS = `http://localhost:${port}`;
  process.env.CYPRESS_SMARTUI_SERVER_ADDRESS = `http://localhost:${port}`;
  return server;
});

// src/lib/env.ts
var env_default = () => {
  const {
    PROJECT_TOKEN = "",
    SMARTUI_CLIENT_API_URL = "https://api.lambdatest.com/visualui/1.0",
    LT_SDK_LOG_LEVEL,
    LT_SDK_DEBUG,
    GITHUB_ACTIONS
  } = process.env;
  return {
    PROJECT_TOKEN,
    SMARTUI_CLIENT_API_URL,
    LT_SDK_LOG_LEVEL,
    LT_SDK_DEBUG,
    GITHUB_ACTIONS
  };
};
var logContext = { task: "smartui-cli" };
function updateLogContext(newContext) {
  logContext = __spreadValues(__spreadValues({}, logContext), newContext);
}
var logLevel = () => {
  let env = env_default();
  let debug = env.LT_SDK_DEBUG === "true" ? "debug" : void 0;
  return debug || env.LT_SDK_LOG_LEVEL || "info";
};
var logger = winston.createLogger({
  level: logLevel(),
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.printf((info) => {
      let contextString = Object.values(logContext).join(" | ");
      let message = typeof info.message === "object" ? JSON.stringify(info.message) : info.message;
      switch (info.level) {
        case "debug":
          message = chalk8__default.default.blue(message);
          break;
        case "warn":
          message = chalk8__default.default.yellow(message);
          break;
        case "error":
          message = chalk8__default.default.red(message);
          break;
      }
      return info.level === "info" ? message : `[${contextString}:${info.level}] ` + message;
    })
  ),
  transports: [new winston.transports.Console()]
});
var logger_default = logger;

// src/tasks/startServer.ts
var startServer_default = (ctx) => {
  return {
    title: `Setting up SmartUI server`,
    task: (ctx2, task) => __async(void 0, null, function* () {
      var _a;
      updateLogContext({ task: "startServer" });
      try {
        ctx2.server = yield server_default(ctx2);
        task.output = chalk8__default.default.gray(`listening on port ${(_a = ctx2.server.addresses()[0]) == null ? void 0 : _a.port}`);
        task.title = "SmartUI started";
      } catch (error) {
        ctx2.log.debug(error);
        task.output = chalk8__default.default.gray(error.message);
        throw new Error("SmartUI server setup failed");
      }
    }),
    rendererOptions: { persistentOutput: true }
  };
};
var auth_default = (ctx) => {
  return {
    title: `Authenticating with SmartUI`,
    task: (ctx2, task) => __async(void 0, null, function* () {
      updateLogContext({ task: "auth" });
      try {
        yield ctx2.client.auth(ctx2.log);
        task.output = chalk8__default.default.gray(`using project token '******#${ctx2.env.PROJECT_TOKEN.split("#").pop()}'`);
        task.title = "Authenticated with SmartUI";
      } catch (error) {
        ctx2.log.debug(error);
        task.output = chalk8__default.default.gray(error.message);
        throw new Error("Authentication failed");
      }
    }),
    rendererOptions: { persistentOutput: true }
  };
};

// package.json
var version = "3.0.3";
var package_default = {
  name: "@lambdatest/smartui-cli",
  version,
  description: "A command line interface (CLI) to run SmartUI tests on LambdaTest",
  files: [
    "dist/**/*"
  ],
  scripts: {
    build: "tsup",
    release: "pnpm run build && pnpm publish --access public --no-git-checks"
  },
  bin: {
    smartui: "./dist/index.cjs"
  },
  type: "module",
  keywords: [
    "lambdatest",
    "smartui",
    "cli"
  ],
  author: "LambdaTest <keys@lambdatest.com>",
  license: "MIT",
  dependencies: {
    "@playwright/browser-chromium": "^1.40.1",
    "@playwright/browser-firefox": "^1.40.1",
    "@playwright/browser-webkit": "^1.40.1",
    "@playwright/test": "^1.40.1",
    "@types/cross-spawn": "^6.0.4",
    "@types/node": "^20.8.9",
    "@types/which": "^3.0.2",
    ajv: "^8.12.0",
    "ajv-errors": "^3.0.0",
    axios: "^1.6.0",
    chalk: "^4.1.2",
    commander: "^11.1.0",
    "cross-spawn": "^7.0.3",
    fastify: "^4.24.3",
    "form-data": "^4.0.0",
    listr2: "^7.0.1",
    tsup: "^7.2.0",
    which: "^4.0.0",
    winston: "^3.10.0"
  },
  devDependencies: {
    typescript: "^5.3.2"
  }
};
var httpClient = class {
  constructor({ SMARTUI_CLIENT_API_URL, PROJECT_TOKEN }) {
    this.axiosInstance = axios__default.default.create({
      baseURL: SMARTUI_CLIENT_API_URL,
      headers: { "projectToken": PROJECT_TOKEN }
    });
  }
  request(config, log) {
    return __async(this, null, function* () {
      log.debug(`http request: ${config.method} ${config.url}`);
      return this.axiosInstance.request(config).then((resp) => {
        log.debug(`http response: ${JSON.stringify({
          status: resp.status,
          headers: resp.headers,
          body: resp.data
        })}`);
        return resp.data;
      }).catch((error) => {
        var _a;
        if (error.response) {
          log.debug(`http response: ${JSON.stringify({
            status: error.response.status,
            headers: error.response.headers,
            body: error.response.data
          })}`);
          throw new Error((_a = error.response.data.error) == null ? void 0 : _a.message);
        }
        if (error.request) {
          log.debug(`http request failed: ${error.toJSON()}`);
          throw new Error(error.toJSON().message);
        }
        log.debug(`http request failed: ${error.message}`);
        throw new Error(error.message);
      });
    });
  }
  auth(log) {
    return this.request({
      url: "/token/verify",
      method: "GET"
    }, log);
  }
  createBuild(git, config, log) {
    return this.request({
      url: "/build",
      method: "POST",
      data: {
        git,
        config
      }
    }, log);
  }
  finalizeBuild(buildId, totalSnapshots, log) {
    let params = { buildId };
    if (totalSnapshots > -1)
      params.totalSnapshots = totalSnapshots;
    return this.request({
      url: "/build",
      method: "DELETE",
      params
    }, log);
  }
  uploadSnapshot(buildId, snapshot, testType, log) {
    return this.request({
      url: `/builds/${buildId}/snapshot`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: {
        snapshot,
        test: {
          type: testType,
          source: "cli"
        }
      }
    }, log);
  }
  uploadScreenshot({ id: buildId, name: buildName, baseline }, ssPath, ssName, browserName, viewport, log) {
    browserName = browserName === constants_default.SAFARI ? constants_default.WEBKIT : browserName;
    const file = fs4__default.default.readFileSync(ssPath);
    const form = new FormData__default.default();
    form.append("screenshot", file, { filename: `${ssName}.png`, contentType: "image/png" });
    form.append("browser", browserName);
    form.append("viewport", viewport);
    form.append("buildId", buildId);
    form.append("buildName", buildName);
    form.append("screenshotName", ssName);
    form.append("baseline", baseline.toString());
    return this.axiosInstance.request({
      url: `/screenshot`,
      method: "POST",
      headers: form.getHeaders(),
      data: form
    }).then(() => {
      log.debug(`${ssName} for ${browserName} ${viewport} uploaded successfully`);
    }).catch((error) => {
      if (error.response) {
        throw new Error(error.response.data.error.message);
      }
      if (error.request) {
        throw new Error(error.toJSON().message);
      }
      throw new Error(error.message);
    });
  }
  checkUpdate(log) {
    return this.request({
      url: `/packageinfo`,
      method: "GET",
      headers: { "Content-Type": "application/json" },
      params: {
        packageName: package_default.name,
        packageVersion: package_default.version
      }
    }, log);
  }
};
var ctx_default = (options) => {
  var _a, _b;
  let env = env_default();
  let webConfig;
  let mobileConfig;
  let config = constants_default.DEFAULT_CONFIG;
  try {
    if (options.config) {
      config = JSON.parse(fs4__default.default.readFileSync(options.config, "utf-8"));
      if ((_a = config.web) == null ? void 0 : _a.resolutions) {
        config.web.viewports = config.web.resolutions;
        delete config.web.resolutions;
      }
      if (!validateConfig(config)) {
        throw new Error(validateConfig.errors[0].message);
      }
    }
  } catch (error) {
    console.log(`[smartui] Error: ${error.message}`);
    process.exit();
  }
  if (config.web) {
    webConfig = { browsers: config.web.browsers, viewports: [] };
    for (let viewport of (_b = config.web) == null ? void 0 : _b.viewports)
      webConfig.viewports.push({ width: viewport[0], height: viewport[1] || 0 });
  }
  if (config.mobile) {
    mobileConfig = {
      devices: config.mobile.devices,
      fullPage: config.mobile.fullPage || true,
      orientation: config.mobile.orientation || constants_default.MOBILE_ORIENTATION_PORTRAIT
    };
  }
  return {
    env,
    log: logger_default,
    client: new httpClient(env),
    config: {
      web: webConfig,
      mobile: mobileConfig,
      waitForPageRender: config.waitForPageRender || 0,
      waitForTimeout: config.waitForTimeout || 0,
      enableJavaScript: config.enableJavaScript || false,
      allowedHostnames: config.allowedHostnames || []
    },
    webStaticConfig: [],
    git: {
      branch: "",
      commitId: "",
      commitAuthor: "",
      commitMessage: "",
      githubURL: ""
    },
    build: {
      id: "",
      name: "",
      baseline: false,
      url: ""
    },
    args: {},
    options: {
      parallel: options.parallel ? true : false
    },
    cliVersion: version,
    totalSnapshots: -1
  };
};
function executeCommand(command3) {
  let dst = process.cwd();
  try {
    return child_process.execSync(command3, {
      cwd: dst,
      stdio: ["ignore"],
      encoding: "utf-8"
    });
  } catch (error) {
    throw new Error(error.message);
  }
}
function isGitRepo() {
  try {
    executeCommand("git status");
    return true;
  } catch (error) {
    return false;
  }
}
var git_default = (ctx) => {
  const splitCharacter = "<##>";
  const prettyFormat = ["%h", "%H", "%s", "%f", "%b", "%at", "%ct", "%an", "%ae", "%cn", "%ce", "%N", ""];
  const command3 = 'git log -1 --pretty=format:"' + prettyFormat.join(splitCharacter) + '" && git rev-parse --abbrev-ref HEAD && git tag --contains HEAD';
  let res = executeCommand(command3).split(splitCharacter);
  var branchAndTags = res[res.length - 1].split("\n").filter((n) => n);
  var branch = branchAndTags[0];
  branchAndTags.slice(1);
  return {
    branch,
    commitId: res[0] || "",
    commitMessage: res[2] || "",
    commitAuthor: res[7] || "",
    githubURL: ctx.env.GITHUB_ACTIONS ? `${constants_default.GITHUB_API_HOST}/repos/${process.env.GITHUB_REPOSITORY}/statuses/${res[1]}` : ""
  };
};
var getGitInfo_default = (ctx) => {
  return {
    title: `Fetching git repo details`,
    skip: (ctx2) => {
      return !isGitRepo() ? "[SKIPPED] Fetching git repo details; not a git repo" : "";
    },
    task: (ctx2, task) => __async(void 0, null, function* () {
      try {
        ctx2.git = git_default(ctx2);
        task.output = chalk8__default.default.gray(`branch: ${ctx2.git.branch}, commit: ${ctx2.git.commitId}, author: ${ctx2.git.commitAuthor}`);
        task.title = "Fetched git information";
      } catch (error) {
        ctx2.log.debug(error);
        task.output = chalk8__default.default.gray(`${error.message}`);
        throw new Error("Error fetching git repo details");
      }
    }),
    rendererOptions: { persistentOutput: true }
  };
};
var createBuild_default = (ctx) => {
  return {
    title: `Creating SmartUI build`,
    task: (ctx2, task) => __async(void 0, null, function* () {
      updateLogContext({ task: "createBuild" });
      try {
        let resp = yield ctx2.client.createBuild(ctx2.git, ctx2.config, ctx2.log);
        ctx2.build = {
          id: resp.data.buildId,
          name: resp.data.buildName,
          url: resp.data.buildURL,
          baseline: resp.data.baseline
        };
        task.output = chalk8__default.default.gray(`build id: ${resp.data.buildId}`);
        task.title = "SmartUI build created";
      } catch (error) {
        ctx2.log.debug(error);
        task.output = chalk8__default.default.gray(error.message);
        throw new Error("SmartUI build creation failed");
      }
    }),
    rendererOptions: { persistentOutput: true }
  };
};
var exec_default = (ctx) => {
  var _a;
  return {
    title: `Executing '${(_a = ctx.args.execCommand) == null ? void 0 : _a.join(" ")}'`,
    task: (ctx2, task) => __async(void 0, null, function* () {
      updateLogContext({ task: "exec" });
      return new Promise((resolve, reject) => {
        var _a2, _b, _c;
        const childProcess = spawn__default.default(ctx2.args.execCommand[0], (_a2 = ctx2.args.execCommand) == null ? void 0 : _a2.slice(1));
        let totalOutput = "";
        const output = listr2.createWritable((chunk) => {
          totalOutput += chunk;
          task.output = chalk8__default.default.gray(totalOutput);
        });
        (_b = childProcess.stdout) == null ? void 0 : _b.pipe(output);
        (_c = childProcess.stderr) == null ? void 0 : _c.pipe(output);
        childProcess.on("error", (error) => {
          var _a3;
          task.output = chalk8__default.default.gray(`error: ${error.message}`);
          throw new Error(`Execution of '${(_a3 = ctx2.args.execCommand) == null ? void 0 : _a3.join(" ")}' failed`);
        });
        childProcess.on("close", (code, signal) => __async(void 0, null, function* () {
          var _a3;
          if (code !== null) {
            task.title = `Execution of '${(_a3 = ctx2.args.execCommand) == null ? void 0 : _a3.join(" ")}' completed; exited with code ${code}`;
          } else if (signal !== null) {
            throw new Error(`Child process killed with signal ${signal}`);
          }
          resolve();
        }));
      });
    }),
    rendererOptions: { persistentOutput: true },
    exitOnError: false
  };
};
var finalizeBuild_default = (ctx) => {
  return {
    title: `Finalizing build`,
    task: (ctx2, task) => __async(void 0, null, function* () {
      updateLogContext({ task: "finalizeBuild" });
      try {
        yield new Promise((resolve) => setTimeout(resolve, 2e3));
        yield ctx2.client.finalizeBuild(ctx2.build.id, ctx2.totalSnapshots, ctx2.log);
        task.output = chalk8__default.default.gray(`build url: ${ctx2.build.url}`);
        task.title = "Finalized build";
      } catch (error) {
        ctx2.log.debug(error);
        task.output = chalk8__default.default.gray(error.message);
        throw new Error("Finalize build failed");
      }
    }),
    rendererOptions: { persistentOutput: true }
  };
};

// src/commander/exec.ts
var command = new commander.Command();
command.name("exec").description("Run test commands around SmartUI").argument("<command...>", "Command supplied for running tests").action(function(execCommand, _, command3) {
  return __async(this, null, function* () {
    var _a, _b;
    let ctx = ctx_default(command3.optsWithGlobals());
    if (!which__default.default.sync(execCommand[0], { nothrow: true })) {
      ctx.log.error(`Error: Command not found "${execCommand[0]}"`);
      return;
    }
    ctx.args.execCommand = execCommand;
    ctx.totalSnapshots = 0;
    let tasks = new listr2.Listr(
      [
        auth_default(),
        startServer_default(),
        getGitInfo_default(),
        createBuild_default(),
        exec_default(ctx),
        finalizeBuild_default()
      ],
      {
        rendererOptions: {
          icon: {
            [listr2.ListrDefaultRendererLogLevels.OUTPUT]: `\u2192`
          },
          color: {
            [listr2.ListrDefaultRendererLogLevels.OUTPUT]: listr2.color.gray
          }
        }
      }
    );
    try {
      yield tasks.run(ctx);
    } catch (error) {
      ctx.log.info("\nRefer docs: https://www.lambdatest.com/support/docs/smart-visual-regression-testing/");
    } finally {
      yield (_a = ctx.server) == null ? void 0 : _a.close();
      yield (_b = ctx.browser) == null ? void 0 : _b.close();
    }
  });
});
var exec_default2 = command;
function createConfig(filepath) {
  filepath = filepath || ".smartui.json";
  let filetype = path2__default.default.extname(filepath);
  if (filetype != ".json") {
    console.log("Error: Config file must have .json extension");
    return;
  }
  if (fs4__default.default.existsSync(filepath)) {
    console.log(`Error: SmartUI Config already exists: ${filepath}`);
    console.log(`To create a new file, please specify the file name like: 'smartui config:create .smartui-config.json'`);
    return;
  }
  fs4__default.default.mkdirSync(path2__default.default.dirname(filepath), { recursive: true });
  fs4__default.default.writeFileSync(filepath, JSON.stringify(constants_default.DEFAULT_CONFIG, null, 2) + "\n");
  console.log(`Created SmartUI Config: ${filepath}`);
}
function createWebStaticConfig(filepath) {
  filepath = filepath || "url.json";
  let filetype = path2__default.default.extname(filepath);
  if (filetype != ".json") {
    console.log("Error: Config file must have .json extension");
    return;
  }
  if (fs4__default.default.existsSync(filepath)) {
    console.log(`Error: web-static config already exists: ${filepath}`);
    console.log(`To create a new file, please specify the file name like: 'smartui config:create-web-static links.json'`);
    return;
  }
  fs4__default.default.mkdirSync(path2__default.default.dirname(filepath), { recursive: true });
  fs4__default.default.writeFileSync(filepath, JSON.stringify(constants_default.DEFAULT_WEB_STATIC_CONFIG, null, 2) + "\n");
  console.log(`Created web-static config: ${filepath}`);
}

// src/commander/config.ts
var configWeb = new commander.Command();
var configStatic = new commander.Command();
configWeb.name("config:create").description("Create SmartUI config file").argument("[filepath]", "Optional config filepath").action(function(filepath, options) {
  return __async(this, null, function* () {
    createConfig(filepath);
  });
});
configStatic.name("config:create-web-static").description("Create Web Static config file").argument("[filepath]", "Optional config filepath").action(function(filepath, options) {
  return __async(this, null, function* () {
    createWebStaticConfig(filepath);
  });
});
function captureScreenshotsForConfig(_0, _1, _2, _3, _4) {
  return __async(this, arguments, function* (ctx, browsers, { name, url, waitForTimeout }, browserName, renderViewports) {
    let pageOptions = { waitUntil: process.env.SMARTUI_PAGE_WAIT_UNTIL_EVENT || "load" };
    let ssId = name.toLowerCase().replace(/\s/g, "_");
    let context;
    let contextOptions = {};
    let page;
    if (browserName == constants_default.CHROME)
      contextOptions.userAgent = constants_default.CHROME_USER_AGENT;
    else if (browserName == constants_default.FIREFOX)
      contextOptions.userAgent = constants_default.FIREFOX_USER_AGENT;
    else if (browserName == constants_default.SAFARI)
      contextOptions.userAgent = constants_default.SAFARI_USER_AGENT;
    else if (browserName == constants_default.EDGE)
      contextOptions.userAgent = constants_default.EDGE_USER_AGENT;
    try {
      const browser = browsers[browserName];
      context = yield browser == null ? void 0 : browser.newContext(contextOptions);
      page = yield context == null ? void 0 : context.newPage();
      yield page == null ? void 0 : page.goto(url.trim(), pageOptions);
      for (let { viewport, viewportString, fullPage } of renderViewports) {
        let ssPath = `screenshots/${ssId}/${`${browserName}-${viewport.width}x${viewport.height}`}-${ssId}.png`;
        yield page == null ? void 0 : page.setViewportSize({ width: viewport.width, height: viewport.height || constants_default.MIN_VIEWPORT_HEIGHT });
        if (fullPage)
          yield page == null ? void 0 : page.evaluate(scrollToBottomAndBackToTop);
        yield page == null ? void 0 : page.waitForTimeout(waitForTimeout || 0);
        yield page == null ? void 0 : page.screenshot({ path: ssPath, fullPage });
        yield ctx.client.uploadScreenshot(ctx.build, ssPath, name, browserName, viewportString, ctx.log);
      }
    } catch (error) {
      throw new Error(`captureScreenshotsForConfig failed for browser ${browserName}; error: ${error}`);
    } finally {
      yield page == null ? void 0 : page.close();
      yield context == null ? void 0 : context.close();
    }
  });
}
function captureScreenshotsAsync(ctx, staticConfig, browsers) {
  return __async(this, null, function* () {
    let capturePromises = [];
    if (ctx.config.web) {
      for (let browserName of ctx.config.web.browsers) {
        let webRenderViewports = getWebRenderViewports(ctx);
        capturePromises.push(captureScreenshotsForConfig(ctx, browsers, staticConfig, browserName, webRenderViewports));
      }
    }
    if (ctx.config.mobile) {
      let mobileRenderViewports = getMobileRenderViewports(ctx);
      if (mobileRenderViewports[constants_default.MOBILE_OS_IOS].length) {
        capturePromises.push(captureScreenshotsForConfig(ctx, browsers, staticConfig, constants_default.SAFARI, mobileRenderViewports[constants_default.MOBILE_OS_IOS]));
      }
      if (mobileRenderViewports[constants_default.MOBILE_OS_ANDROID].length) {
        capturePromises.push(captureScreenshotsForConfig(ctx, browsers, staticConfig, constants_default.CHROME, mobileRenderViewports[constants_default.MOBILE_OS_ANDROID]));
      }
    }
    return Promise.all(capturePromises);
  });
}
function captureScreenshotsSync(ctx, staticConfig, browsers) {
  return __async(this, null, function* () {
    if (ctx.config.web) {
      for (let browserName of ctx.config.web.browsers) {
        let webRenderViewports = getWebRenderViewports(ctx);
        yield captureScreenshotsForConfig(ctx, browsers, staticConfig, browserName, webRenderViewports);
      }
    }
    if (ctx.config.mobile) {
      let mobileRenderViewports = getMobileRenderViewports(ctx);
      if (mobileRenderViewports[constants_default.MOBILE_OS_IOS].length) {
        yield captureScreenshotsForConfig(ctx, browsers, staticConfig, constants_default.SAFARI, mobileRenderViewports[constants_default.MOBILE_OS_IOS]);
      }
      if (mobileRenderViewports[constants_default.MOBILE_OS_ANDROID].length) {
        yield captureScreenshotsForConfig(ctx, browsers, staticConfig, constants_default.CHROME, mobileRenderViewports[constants_default.MOBILE_OS_ANDROID]);
      }
    }
  });
}
function captureScreenshots(ctx) {
  return __async(this, null, function* () {
    delDir("screenshots");
    let browsers = {};
    let capturedScreenshots = 0;
    let output = "";
    try {
      browsers = yield launchBrowsers(ctx);
    } catch (error) {
      yield closeBrowsers(browsers);
      ctx.log.debug(error);
      throw new Error(`Failed launching browsers`);
    }
    for (let staticConfig of ctx.webStaticConfig) {
      try {
        if (ctx.options.parallel)
          yield captureScreenshotsAsync(ctx, staticConfig, browsers);
        else
          yield captureScreenshotsSync(ctx, staticConfig, browsers);
        delDir(`screenshots/${staticConfig.name.toLowerCase().replace(/\s/g, "_")}`);
        output += `${chalk8__default.default.gray(staticConfig.name)} ${chalk8__default.default.green("\u2713")}
`;
        ctx.task.output = output;
        capturedScreenshots++;
      } catch (error) {
        ctx.log.debug(`screenshot capture failed for ${JSON.stringify(staticConfig)}; error: ${error}`);
        output += `${chalk8__default.default.gray(staticConfig.name)} ${chalk8__default.default.red("\u2717")}
`;
        ctx.task.output = output;
      }
    }
    yield closeBrowsers(browsers);
    delDir("screenshots");
    return { capturedScreenshots, output };
  });
}
var captureScreenshots_default = (ctx) => {
  return {
    title: "Capturing screenshots",
    task: (ctx2, task) => __async(void 0, null, function* () {
      try {
        ctx2.task = task;
        updateLogContext({ task: "capture" });
        let { capturedScreenshots, output } = yield captureScreenshots(ctx2);
        if (capturedScreenshots != ctx2.webStaticConfig.length) {
          throw new Error(output);
        }
        task.title = "Screenshots captured successfully";
      } catch (error) {
        ctx2.log.debug(error);
        task.output = chalk8__default.default.gray(`${error.message}`);
        throw new Error("Capturing screenshots failed");
      }
    }),
    rendererOptions: { persistentOutput: true },
    exitOnError: false
  };
};

// src/commander/capture.ts
var command2 = new commander.Command();
command2.name("capture").description("Capture screenshots of static sites").argument("<file>", "Web static config file").option("--parallel", "Capture parallely on all browsers").action(function(file, _, command3) {
  return __async(this, null, function* () {
    let ctx = ctx_default(command3.optsWithGlobals());
    if (!fs4__default.default.existsSync(file)) {
      console.log(`Error: Web Static Config file ${file} not found.`);
      return;
    }
    try {
      ctx.webStaticConfig = JSON.parse(fs4__default.default.readFileSync(file, "utf8"));
      if (!validateWebStaticConfig(ctx.webStaticConfig))
        throw new Error(validateWebStaticConfig.errors[0].message);
    } catch (error) {
      console.log(`[smartui] Error: Invalid Web Static Config; ${error.message}`);
      return;
    }
    let tasks = new listr2.Listr(
      [
        auth_default(),
        getGitInfo_default(),
        createBuild_default(),
        captureScreenshots_default(),
        finalizeBuild_default()
      ],
      {
        rendererOptions: {
          icon: {
            [listr2.ListrDefaultRendererLogLevels.OUTPUT]: `\u2192`
          },
          color: {
            [listr2.ListrDefaultRendererLogLevels.OUTPUT]: listr2.color.gray
          }
        }
      }
    );
    try {
      yield tasks.run(ctx);
    } catch (error) {
      console.log("\nRefer docs: https://www.lambdatest.com/support/docs/smart-visual-regression-testing/");
    }
  });
});
var capture_default = command2;

// src/commander/commander.ts
var program = new commander.Command();
program.name("smartui").description("CLI to help you run your SmartUI tests on LambdaTest platform").version(`v${version}`).option("-c --config <filepath>", "Config file path").addCommand(exec_default2).addCommand(capture_default).addCommand(configWeb).addCommand(configStatic);
var commander_default = program;
(function() {
  return __async(this, null, function* () {
    let client = new httpClient(env_default());
    let log = logger_default;
    try {
      log.info(`
LambdaTest SmartUI CLI v${package_default.version}`);
      let { data: { latestVersion, deprecated } } = yield client.checkUpdate(log);
      if (deprecated)
        log.warn(`This version is deprecated. A new version ${latestVersion} is available!
`);
      else if (package_default.version !== latestVersion)
        log.info(chalk8__default.default.gray(`A new version ${latestVersion} is available!
`));
      else
        log.info(chalk8__default.default.gray("https://www.npmjs.com/package/@lambdatest/smartui-cli\n"));
    } catch (error) {
      log.debug(error);
      log.info(chalk8__default.default.gray("https://www.npmjs.com/package/@lambdatest/smartui-cli\n"));
    }
    commander_default.parse();
  });
})();
